Test는 무조건 실패까지 체크하는게 확실함

애플리케이션을 하나의 공연으로 생각.
기존에는 클라이언트가 의존하는 서버 구현 객체를 직접 생성하고 실행함.
비유를 하면 기존에는 남자 주인공 배우가 공연도 하고 동시에 여자주인공도 직접 초빙하는 다양한 책임을 가지고있음
공연을 구성하고 담당배우를 섭외하고 세세한것을 관리할 공연 기획자가 나올 시점

그것이 "AppConfig"

AppConfig는 애플리케이션의 전체 동작 방식을 구성(Config)하기위해 "구현객체를 생성"하고 연결 하는책임
이제부터 클라이언트 객체는 자신의 역할을 실행하는 것만 집중 권한이 줄어듬 . (하지만 책임은 명확해짐)


AppConfig리팩터링
구성정보에서 역할과 구현을 명확하게 분리
역할이 잘 들어나고 중복을 제거함
 사용과 구성영역이 확실하게 구분이 됨
 -------------------------------------
 SRP 단일 책임 원칙
 *한 클래스는 하나의 책임만 가져야 한다.
 클라이언트 객체(Service)는 직접 구현객체를 생성하고 연결하고 실행하는 다양한 책임을 가지고 있음
 SRP 단일 책임 원칙을 따르면서 관심사를 분리함
 구현객체를 생성하고 연결하는 책임은 AC이 담당
 클라이언느 객체는 실행하는 책임만 담당

 ------------------------------

 DIP 의존관계 역전 원칙
 *프로그래머는"추상화에 의존해야지, 구체화에 의존하면 안된다." 의존성 주입은 이 원칙을 따르는 방법 중 하나다.

 새로운 할인 정책을 개발하고 적용하려고 하니 클라이언트 코드도 함께 번경해야했다 왜냐하면 기존 클라이언트 코드(OrderServiceImpl)는 DIP를 지키며
 DiscountPolicy 추상화 인터페이스에 의존하는 것 같았지만 FIxDisCountPolicy 추상화 인터페이스에만 의존하도록 코드를 변경했다.
 하지만 클라이언트 코드는 인터페이스만으로는 아무것도 실행할 수 없다.
 AC가 Fix객체 인스턴스를 클라이언트 코드 대신 생성해서 클라이언트 코드에 의존관계를 주입 했다

 ------------------------------

 OCP
 *소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.*
 다형성 사용하고 클라이언트가 DIP를 지킴
 애플리케이션을 사용 영역과 구성 영역으로 나눔
 AppConfig가 의존관계를 Fix -> Rate로 변경해서 클라이언트 코드에 주입하므로 클라이언트 코드는 변경하지 않아도 됨
 소프트웨어 요소를 새롭게 확장해도 사용 영역의 변경은 닫혀있다!
---------------------------
제어의 역전 IoC( Inversion of Control)
기존 프로그램은 클라이언트 구현 객체가 스스로 필요한 서버 구현 객체를 생성하고 연결하고 실행했다.
 한마디로 구현 객체가 프로그램의 제어 흐름을 스스로 조종했다. 개발자 입장에서는 자연스러운 흐름.
 반면 AppConfig가 등장한 이후 사용,구성영역이 나누어짐
 프로그램의 제어 흐름 자체는 AppConfig가 가져감

--------------------------------------------------------------------------
ApplicationContext는 스프링 컨테이너이고 인터페이스다. 그렇기때문에 다형성이 적용이 된다

BeanFactory
스프링 컨테이너의 최상위 인터페이스
스프링빈을 관리하고 조회하는 역할
getBean()을 제공함
지금까지 우리가 사용했던 대부분 기능은 BF기능

ApplicationContext
BF의 기능을 모두 상속받아 제공함
빈을 관리하고 검색하는 기능을 BF가 제공해주는데 무슨차이?
애플리케이션을 개발할 댸는 빈은 관리하고 조회하는 기능은 물론 수많은 부가기능이필요함
*메시지소스를 활용한 국제회기능 : 예를 들어서 한국에서 들어오면한국어로 영어권은 영어로 출력

환경변수 : 로컬, 개발 , 운영등을 구분해서 처리.

애플리케이션 이벤트 : 이벤트를 발행하고 구독하는 모델을 편리하게 지원

편리한 리소스 조회 : 파일 , 클래스패스, 외부 등에서 리소스를 편리하게 조회가능

*정리*
ApplicationContext 는 BF의 기능을 상속받고 빈 관리기능 + 편리한 부가기능을 제공.
BF를 직접 사용할 일은 거의 없음. 부가기능이 포함된 ApplicationContext를 사용
BF나 ApplicationContext를 스프링컨테이너라고 함
------------------------------------------------------------------------------------------------------------
BeanDefinition 정보
BeanClassName: 생성할 빈의 클래스 명(자바 설정 처럼 팩토리 역할의 빈을 사용하면 없음)

factoryBeanName: 팩토리 역할의 빈을 사용할 경우 이름, 예) appConfig

factoryMethodName: 빈을 생성할 팩토리 메서드 지정, 예) memberService

Scope: 싱글톤(기본값)

 lazyInit: 스프링 컨테이너를 생성할 때 빈을 생성하는 것이 아니라, 실제 빈을 사용할 때 까지 최대한 생성을 지연처리 하는지 여부

InitMethodName: 빈을 생성하고, 의존관계를 적용한 뒤에 호출되는 초기화 메서드 명
DestroyMethodName: 빈의 생명주기가 끝나서 제거하기 직전에 호출되는 메서드 명
Constructor arguments, Properties: 의존관계 주입에서 사용한다.
(자바 설정 처럼 팩토리 역할의 빈을 사용하면 없음)

정리
BeanDefinition을 직접 생성해서 스프링 컨테이너에 등록할 수 도 있다.

하지만 실무에서 BeanDefinition을 직접 정의하거나 사용할 일은 거의 없다. 어려우면 그냥 넘어가면 된다^^!

BeanDefinition에 대해서는 너무 깊이있게 이해하기 보다는,

스프링이 다양한 형태의 설정 정보를 BeanDefinition으로 추상화해서 사용하는 것 정도만 이해하면 된다.

가끔 스프링 코드나 스프링 관련 오픈 소스의 코드를 볼 때, BeanDefinition 이라는 것이 보일 때가 있다.
이때 이러한 메커니즘을 떠올리면 된다.

------------------------------------------------------------------------------------------------------------
싱글톤 1
스프링은 태생이 기업용 온라인 서비스 기술을 지원하기위해 탄생
대부분 스프링 애플리케이션은 웹 애플리케이션이다 물론 웹이 아닌 애플리케이션 개발도 가능
웹 애플리케이션은 보통 여러고객이 동시에 요청한다

















