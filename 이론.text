Test는 무조건 실패까지 체크하는게 확실함

애플리케이션을 하나의 공연으로 생각.
기존에는 클라이언트가 의존하는 서버 구현 객체를 직접 생성하고 실행함.
비유를 하면 기존에는 남자 주인공 배우가 공연도 하고 동시에 여자주인공도 직접 초빙하는 다양한 책임을 가지고있음
공연을 구성하고 담당배우를 섭외하고 세세한것을 관리할 공연 기획자가 나올 시점

그것이 "AppConfig"

AppConfig는 애플리케이션의 전체 동작 방식을 구성(Config)하기위해 "구현객체를 생성"하고 연결 하는책임
이제부터 클라이언트 객체는 자신의 역할을 실행하는 것만 집중 권한이 줄어듬 . (하지만 책임은 명확해짐)


AppConfig리팩터링
구성정보에서 역할과 구현을 명확하게 분리
역할이 잘 들어나고 중복을 제거함
 사용과 구성영역이 확실하게 구분이 됨
 -------------------------------------
 SRP 단일 책임 원칙
 *한 클래스는 하나의 책임만 가져야 한다.
 클라이언트 객체(Service)는 직접 구현객체를 생성하고 연결하고 실행하는 다양한 책임을 가지고 있음
 SRP 단일 책임 원칙을 따르면서 관심사를 분리함
 구현객체를 생성하고 연결하는 책임은 AC이 담당
 클라이언느 객체는 실행하는 책임만 담당

 ------------------------------

 DIP 의존관계 역전 원칙
 *프로그래머는"추상화에 의존해야지, 구체화에 의존하면 안된다." 의존성 주입은 이 원칙을 따르는 방법 중 하나다.

 새로운 할인 정책을 개발하고 적용하려고 하니 클라이언트 코드도 함께 번경해야했다 왜냐하면 기존 클라이언트 코드(OrderServiceImpl)는 DIP를 지키며
 DiscountPolicy 추상화 인터페이스에 의존하는 것 같았지만 FIxDisCountPolicy 추상화 인터페이스에만 의존하도록 코드를 변경했다.
 하지만 클라이언트 코드는 인터페이스만으로는 아무것도 실행할 수 없다.
 AC가 Fix객체 인스턴스를 클라이언트 코드 대신 생성해서 클라이언트 코드에 의존관계를 주입 했다

 ------------------------------

 OCP
 *소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.*
 다형성 사용하고 클라이언트가 DIP를 지킴
 애플리케이션을 사용 영역과 구성 영역으로 나눔
 AppConfig가 의존관계를 Fix -> Rate로 변경해서 클라이언트 코드에 주입하므로 클라이언트 코드는 변경하지 않아도 됨
 소프트웨어 요소를 새롭게 확장해도 사용 영역의 변경은 닫혀있다!
---------------------------
제어의 역전 IoC( Inversion of Control)
기존 프로그램은 클라이언트 구현 객체가 스스로 필요한 서버 구현 객체를 생성하고 연결하고 실행했다.
 한마디로 구현 객체가 프로그램의 제어 흐름을 스스로 조종했다. 개발자 입장에서는 자연스러운 흐름.
 반면 AppConfig가 등장한 이후 사용,구성영역이 나누어짐
 프로그램의 제어 흐름 자체는 AppConfig가 가져감

--------------------------------------------------------------------------
ApplicationContext는 스프링 컨테이너이고 인터페이스다. 그렇기때문에 다형성이 적용이 된다
